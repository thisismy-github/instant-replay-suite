''' This script compiles Instant Replay Suite to an executable. Make sure all
    appropriate libraries in requirements.txt are installed. View !readme.txt
    for more information. Cross-platform features are holdovers as this script
    was adapted from the version I made for PyPlayer.

    A virtualenv is highly recommended for an accurate release folder.
    If you do not run this script from within it, the script will
    reopen itself within the virtualenv automatically.

    thisismy-github 4/16/22 '''


import os
import sys
import glob
import shutil
import platform
import subprocess


pjoin = os.path.join
PLATFORM = platform.system()

CWD = os.path.dirname(os.path.realpath(__file__))
SCRIPT_DIR = os.path.dirname(CWD)
RELEASE_DIR = pjoin(CWD, 'compiling', 'release')
FINAL_RELEASE_DIR = pjoin(CWD, 'compiled')
BIN_DIR = pjoin(RELEASE_DIR, 'bin')


# ensure python is running from a venv, if possible
if 'venv' not in sys.executable.split(os.sep):
    VENV_DIR = pjoin(SCRIPT_DIR, 'venv')
    if not os.path.exists(VENV_DIR): VENV_DIR = pjoin(CWD, 'venv')

    if PLATFORM == 'Windows': venv = pjoin(VENV_DIR, 'Scripts', 'python.exe')
    else: venv = pjoin(VENV_DIR, 'bin', 'python3')
    if os.path.exists(venv):
        print(f'Restarting with virtual environment at "{venv}"')
        process = subprocess.Popen(f'"{venv}" "{sys.argv[0]}"', shell=True)
        process.wait()
        sys.exit(0)


def get_default_resources():
    ''' Moves the "resources" folder to the root directory
        and generates a new "!defaults.txt" file. '''
    resource_dir = pjoin(RELEASE_DIR, 'resources')
    shutil.move(pjoin(BIN_DIR, 'resources'), resource_dir)
    output = pjoin(resource_dir, '!defaults.txt')

    comments = '''
// This lists the current default resources and their sizes. This
// is used to detect which resources should not be replaced while
// updating. Do not edit this file.
'''

    with open(output, 'w') as out:
        out.write(comments.strip() + '\n\n')

        for filename in os.listdir(resource_dir):
            if filename[-4:] != '.txt':
                path = pjoin(resource_dir, filename)
                out.write(f'{filename}: {os.path.getsize(path)}\n')


def compile():
    print(f'\nCompiling Instant Replay Suite (sys.executable="{sys.executable}")...\n')
    pyinstaller = f'"{sys.executable}" -m PyInstaller'
    args = f'--distpath "{pjoin(CWD, "compiling")}" --workpath "{pjoin(CWD, "build")}"'
    subprocess.run(f'{pyinstaller} "{pjoin(CWD, "main.spec")}" --noconfirm {args}')
    subprocess.run(f'{pyinstaller} "{pjoin(CWD, "updater.spec")}" --noconfirm {args}')

    print('Moving updater to bin folder...')
    name = 'updater' + ('.exe' if PLATFORM == 'Windows' else '')
    shutil.move(pjoin(os.path.dirname(RELEASE_DIR), name), pjoin(BIN_DIR, name))

    for file in ('config.settings.ini', 'config.menu.ini', 'history.txt', 'undo.txt'):
        print(f'Checking for pre-existing "{file}" file to reuse...')
        override_path = pjoin(CWD, file)
        existing_path = pjoin(FINAL_RELEASE_DIR, file)
        if os.path.exists(override_path):
            print(f'Copying override-file for "{file}" from current directory...')
            shutil.copyfile(override_path, pjoin(RELEASE_DIR, file))
        elif os.path.exists(existing_path):
            print(f'Copying pre-existing "{file}" from previous build...')
            shutil.copyfile(existing_path, pjoin(RELEASE_DIR, file))
        else:
            print(f'No pre-existing "{file}" file detected, skipping...')

    exclude_path = pjoin(CWD, 'exclude.txt')
    print(f'Deleting files defined in {exclude_path}...')
    if os.path.exists(exclude_path):
        with open(exclude_path) as exclude:
            for line in exclude:
                line = line.strip()
                if line and line[0] not in '#;' and line[:2] != '//':
                    for path in glob.glob(pjoin(BIN_DIR, line)):
                        print(f'exists={os.path.exists(path)} - {path}')
                        if os.path.exists(path):
                            if os.path.isdir(path): shutil.rmtree(path)
                            else: os.remove(path)

    print('Generating "!defaults.txt" file for resources...')
    get_default_resources()


# ---------------------
# Windows
# ---------------------
def compile_windows():
    compile()
    print(f'\nPerforming post-compilation tasks for {PLATFORM}...')

    print('Flattening and removing all subdirectories in the "bin" folder...')
    for filename in os.listdir(BIN_DIR):
        folder = pjoin(BIN_DIR, filename)
        if os.path.isdir(folder):
            for path in glob.glob(pjoin(folder, '*.*')):
                flattened_path = pjoin(BIN_DIR, os.path.basename(path))
                print(f'{path} -> {flattened_path}')
                shutil.move(path, flattened_path)
            os.rmdir(folder)


#######################################
if __name__ == '__main__':
    while True:
        try:
            compile_windows() if PLATFORM == 'Windows' else compile()

            if os.path.exists(FINAL_RELEASE_DIR):
                print('Deleting old build...')
                shutil.rmtree(FINAL_RELEASE_DIR)
            else:
                print('No previous build detected, skipping...')

            print('Compile finished, renaming "compiling" to "compiled"...')
            os.renames(RELEASE_DIR, FINAL_RELEASE_DIR)

            if input('\nDone! Type anything to exit, or press enter to recompile... '):
                break
        except:
            import traceback
            input(f'\n(!) Compile failed:\n\n{traceback.format_exc()}')
